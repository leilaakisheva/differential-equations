# -*- coding: utf-8 -*-
"""10

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16SR2PUmeA2UXADT1KMqIn6yxiefJCEXL
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import odeint

G=6.67e-11
M=1.989e30

"""#**Assignment 10**
###**Abstract**
In this assignment, I have solved the differential equation of motion for a planet around the Sun, assuming purely circular orbit using two numerical methods, Euler's method and Runge-Kutta's method. The initial conditions for the position and velocity of the planet Mercury have been defined, and the trajectory of the planet has been plotted for 180 days and 1 year for both methods. Furthermore, the relative error has been calculated for both methods and compared to determine the accuracy of the numerical solutions.
###**Introduction**
The motion of a planet around the Sun can be described by a differential equation that relates the acceleration of the planet to the gravitational force exerted by the Sun. The objective is to determine the accuracy of the numerical solutions and compare the results obtained from the two methods. I chose the planet **Mercury** as an example and defined the initial conditions for its position and velocity. The trajectory of the planet was plotted for 180 days and 1 year for both methods, and the relative error was calculated to determine the accuracy of the numerical solutions.

###**Methods**
First I separate differential equations for x and y. Then I define euler function and rk4 function, which were bases on the Euler's and Runge-Kutta's methods.
"""

def dxdt(x, y):
  r=np.sqrt(x**2+y**2)
  ax=-G*M*x/r**3
  return ax
def dydt(x, y):
  r=np.sqrt(x**2 + y**2)
  ay=-G*M*y/r**3
  return ay

def euler(x0, y0, vx0, vy0, dt, t_max):
  t=np.arange(0, t_max, dt)
  x=np.zeros(len(t))
  y=np.zeros(len(t))
  vx=np.zeros(len(t))
  vy=np.zeros(len(t))
  x[0], y[0], vx[0], vy[0]=x0, y0, vx0, vy0
  for i in range(1, len(t)):
    #acceleration
    ax=dxdt(x[i-1], y[i-1])
    ay=dydt(x[i-1], y[i-1])
    #the position and velocity
    #Euler form
    x[i]=x[i-1]+vx[i-1]*dt
    y[i]=y[i-1]+vy[i-1]*dt
    vx[i]=vx[i-1]+ax*dt
    vy[i]=vy[i-1]+ay*dt
  return x, y

def rk4(x0, y0, vx0, vy0, dt, t_max):
  t=np.arange(0, t_max, dt)
  x=np.zeros(len(t))
  y=np.zeros(len(t))
  vx=np.zeros(len(t))
  vy=np.zeros(len(t))
  x[0], y[0], vx[0], vy[0]=x0, y0, vx0, vy0
  for i in range(1, len(t)):
    k1x=dxdt(x[i-1], y[i-1])
    k1y=dydt(x[i-1], y[i-1])
    k2x=dxdt(x[i-1]+0.5*k1x*dt, y[i-1]+0.5*k1y*dt)
    k2y=dydt(x[i-1]+0.5*k1x*dt, y[i-1]+0.5*k1y*dt)
    k3x=dxdt(x[i-1]+0.5*k2x*dt, y[i-1]+0.5*k2y*dt)
    k3y=dydt(x[i-1]+0.5*k2x*dt, y[i-1]+0.5*k2y*dt)
    k4x=dxdt(x[i-1]+k3x*dt, y[i-1]+k3y*dt)
    k4y=dydt(x[i-1]+k3x*dt, y[i-1]+k3y*dt)
    vx[i]=vx[i-1]+(k1x/6+k2x/3+k3x/3+k4x/6)*dt
    vy[i]=vy[i-1]+(k1y/6+k2y/3+k3y/3+k4y/6)*dt
    x[i]=x[i-1]+0.5*(vx[i-1]+vx[i])*dt
    y[i]=y[i-1]+0.5*(vy[i-1]+vy[i])*dt
  return x,y

#initial conditions of the Mercury
#https://solarsystem.nasa.gov/planets/mercury/in-depth/#:~:text=From%20an%20average%20distance%20of,from%20the%20Sun%20to%20Mercury.
x0=3.969e10     #initial x position of the planet
y0=3.969e10     #initial y position of the planet
vx0=0           #initial x velocity of the planet
vy0=4.7e4       #initial y velocity of the planet
dt=1000         #time step (in seconds)
t_max=180*24*3600    #duration (180days)
t_max2=365*24*3600

x_rk1,y_rk1=rk4(x0, y0, vx0, vy0, dt, t_max)
x_e1,y_e1=euler(x0,y0,vx0,vy0,dt,t_max)
x_e2,y_e2=euler(x0,y0,vx0,vy0,dt,t_max2)
x_rk2,y_rk2=rk4(x0,y0,vx0,vy0,dt,t_max2)

fig, ((ax1, ax2),(ax3,ax4)) = plt.subplots(2, 2, figsize=(8,8))
ax1.plot(x_e1, y_e1, color="green")
ax2.plot(x_rk1, y_rk1)
ax3.plot(x_e2, y_e2, color="green")
ax4.plot(x_rk2, y_rk2)
ax1.text(-0.5e10, 0, '$sun$', fontsize=10)
ax2.text(-0.5e10, 0, '$sun$', fontsize=10)
ax3.text(-0.5e10, 0, '$sun$', fontsize=10)
ax4.text(-0.5e10, 0, '$sun$', fontsize=10)
ax1.plot(0,0,marker="o", markersize=20, markeredgecolor="red", color="orange")
ax1.set_title("Euler (180 days)", fontsize=10)
ax2.set_title("RK4  (180 days)", fontsize=10)
ax3.set_title("Euler (360 days)", fontsize=10)
ax4.set_title("RK4 (360 days)", fontsize=10)
ax2.plot(0,0,marker="o", markersize=20, markeredgecolor="red", color="orange")
ax3.plot(0,0,marker="o", markersize=20, markeredgecolor="red", color="orange")
ax4.plot(0,0,marker="o", markersize=20, markeredgecolor="red", color="orange")
ax1.grid()
ax2.grid()
ax3.grid()
ax4.grid()

t=np.linspace(0,t_max, 15552)
t2=np.linspace(0, t_max2, 31536)
init=[x0, y0, vx0, vy0]
def f(init, t):
    x, y, vx, vy=init
    ax=dxdt(x,y)
    ay=dydt(x,y)
    return [vx, vy, ax, ay]
exact1=odeint(f, init, t)
exact2=odeint(f,init,t2)
#relative error
euler_error1=abs(np.sqrt(np.square(exact1[:, 0])+np.square(exact1[:, 2]))-np.sqrt(np.square(x_e1)+np.square(y_e1)))/(np.sqrt(np.square(exact1[:, 0])+np.square(exact1[:, 2])))
euler_error2=abs(np.sqrt(np.square(exact2[:, 0])+np.square(exact2[:, 2]))-np.sqrt(np.square(x_e2)+np.square(y_e2)))/(np.sqrt(np.square(exact2[:, 0])+np.square(exact2[:, 2])))
rk_error1=abs(np.sqrt(np.square(exact1[:, 0])+np.square(exact1[:, 2]))-np.sqrt(np.square(x_rk1)+np.square(y_rk1)))/(np.sqrt(np.square(exact1[:, 0])+np.square(exact1[:, 2])))
rk_error2=abs(np.sqrt(np.square(exact2[:, 0])+np.square(exact2[:, 2]))-np.sqrt(np.square(x_rk2)+np.square(y_rk2)))/(np.sqrt(np.square(exact2[:, 0])+np.square(exact2[:, 2])))

fig, ((ax1, ax2),(ax3,ax4)) = plt.subplots(2, 2, figsize=(7,6))
ax1.plot(t, euler_error1, color="red")
ax2.plot(t, rk_error1, color="green")
ax3.plot(t2, euler_error2, color="red")
ax4.plot(t2, rk_error2, color="green")
ax1.set_title("Euler (180 days)", fontsize=8)
ax2.set_title("RK4  (180 days)", fontsize=8)
ax3.set_title("Euler (360 days)", fontsize=8)
ax4.set_title("RK4 (360 days)", fontsize=8)

"""###**Results**
It can be seen that as the number of iterations increases the Euler's method is  less accurate and the relative error increases. This can be also seen in the plot: the calculated trajectory of the Mercury using Euler method has a very big deviation.

###**Conclusion**
In conclusion, the ODE was successfully solved using Euler's method and Runge-Kutta's method. The accuracy of the numerical solutions was determined by calculating the relative error, and it was found that Runge-Kutta's method produced more accurate results.
"""

